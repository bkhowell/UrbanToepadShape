#clear all current variables or functions from R memory and start (or restart) script/anayses
rm(list = ls(all = TRUE)) 

###### Howell Puerto Rican Anole Toe Pad Shape Geometric Morphometric Analyses ######

  ## Please run the "Howell PR Preliminary Data Setup.R" script prior to this script.
  ## It generates the required "Howell R data.Rdata" file needed for these analyses

## Necessry files for this R script

  # Howell R data.Rdata - generated by the "Howell PR Preliminary Data Setup.R" script 

## Packages used in this script 

  #library(geomorph)
  packageVersion("geomorph")
  #3.3.1
  
  #library(Morpho)
  packageVersion("Morpho")
  #2.7
  
## Custom functions included in this script 

  # Compare_shape() - plots a side by side comparion of two shape variables 

## My Current R and RStudio Versions 
  
  #check version of R
  getRversion()
  #R version 3.5.3

  #check R studio version
  require(rstudioapi)
  versionInfo()$version
  #RStudio version 1.1.463

######
###### Initial Geometric Morphometric Analyses ######

#Load geomoprh libary
library(geomorph)

#Set working directory
### CHANGE THIS if not already in correct working directory###
setwd("UrbanToepadShape")

load(file="Howell R data.Rdata") #Load the previously generated data file. 

#Save the imported datasets to their own objects
dat.raw<-Howell_dat$dat.raw
dat.super<-Howell_dat$dat.super 
dat.field<-Howell_dat$dat.field 

#Set relevant variables as factors 
dat.field$Habitat_Category<-as.factor(dat.field$Habitat_Category)
dat.field$Municipality<-as.factor(dat.field$Municipality)

#get sample sizes for each site within each municipality 
table(paste(as.character(dat.field$Municipality), as.character(dat.field$Habitat_Category), as.character(dat.field$Site), sep="_"))

  #Aguadilla_forest_Ruinas Faro           13
  #Aguadilla_urban_Ramey                  16
  #Arecibo_forest_Mata de Platano         17
  #Arecibo_urban_University               20
  #Arecibo_urban_UPRA                     20
  #Mayaguez_forest_Miradero Forest        20
  #Mayaguez_forest_zoo forest             20
  #Mayaguez_urban_Maya_urban2             20
  #Mayaguez_urban_RUM housing             20
  #Ponce_forest_ponce forest              20
  #Ponce_urban_ponce urban                20
  #San Juan_forest_Bosque San Patricio    20
  #San Juan_urban_University Gardens      20

## Does toe pad shape correlate with habitat type? 

#Build a geomorph data frame
gdf <- geomorph.data.frame(Coords=dat.super$coords, Category = dat.field$Habitat_Category, Municipality=dat.field$Municipality)

#Does habitat category and municipality interact to predcit shape? SS.type="II" denotes the use of a type II sum of squares
fit<-procD.lm(Coords~Category*Municipality, data = gdf, SS.type="II") 
summary(fit) 

## YES, both variables and the interaction were signifincat (p=0.001 for all three)


#Also evaluate morphological disparity (amount of shape variation) between urban and forest habitats, taking into account municipality
out<-morphol.disparity(Coords~Category*Municipality, groups = ~ Category, data=gdf, print.progress = FALSE)
out$PV.dist.Pval[1,2] #Pval = 0.026 meaning significant difference  between forest and urban
out$Procrustes.var["urban"]/out$Procrustes.var["forest"] #1.18982 meaning urban is 18% more variable


#Plot both pre-aligned and aligned mean toe pad shapes of urban and forest lizards

#Before we run make these plots, we must prepre our shape data for plotting
#We need to rotate our unaligned data to all be facing the same way before we calculate mean shape for our urban and forest samples

#We will use one our aligned specimens as a template
#As output from geomorph's gpagen() function, our aligned toe pad data are all aligend horizontally
#We want our toe pad images to face vertically

dat.super.vert<-rotate.coords(dat.super$coords[,,], type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise

#use one of our vertically rotated aligned specimne as a template to rotate our pre-aligned data 
template<-dat.super.vert[,,1]

library(Morpho) #this library contains the rotate functions we need

#loop through our pre-aligned dataset to rotate each specimen to match the vertical template 

dat.raw.vert<-dat.raw #duplicate our dat.raw dataset to generate a vertically aligned dataset

for(s in 1:dim(dat.raw.vert)[3]){
  #s<-1
  rot<-rotonto(x=template, y=dat.raw.vert[,,s], reflection=F, scale=T) #Note that we are not allowing reflections, but  are allowing scaling. We reverse the scaling in later steps of the loop
  dat.raw.vert[,,s]<-rot$yrot/rot$bet #here we reverse the scaling to return our pre-aligned samples to their origional size
}

#Overlay all vertical pre-alignment specimens just to make sure they look the way they should
plot(dat.raw.vert[,1,], dat.raw.vert[,2,], asp=1, col="grey", pch=19, cex=0.5, xlab=NA, ylab=NA)
points(mshape(dat.raw.vert), col="red", pch=19, cex=0.5)
#more messy, but that's to be expected with pre-aligned non-scaled data

#Now that our pre-aligned and aligned data are all facing vertically, we can calculate means for our habitat categories

mshape.urban.raw<-mshape(dat.raw.vert[,,dat.field$Habitat_Category=="urban"]) #get the mean pre-alignment shape of urban lizards 
mshape.forest.raw<-mshape(dat.raw.vert[,,dat.field$Habitat_Category=="forest"]) #get the mean pre-alignment shape of forest lizards 

mshape.urban.super<-mshape(dat.super.vert[,,dat.field$Habitat_Category=="urban"]) #get the mean aligned shape of urban lizards 
mshape.forest.super<-mshape(dat.super.vert[,,dat.field$Habitat_Category=="forest"]) #get the mean aligned shape of forest lizards 

#We now run a custom fucntion to plot and comapre mean shape data
### MUST LOAD FUNCTION ###
#Run the Compare_shape() function 

###### FUNCTION Compare_shape() - plots two shapes side by side for visual comparison   ####

## Arguments
# shape_urb - mean shape of urban specimens (only the "matrix" data from the mshape() function)
# shape_nat - mean shape of forest specimens (only the "matrix" data from the mshape() function)
# spread - a numeric value to control the horizontal spacing of the two shapes

Compare_shape<-function(shape_nat, shape_urb, col_nat_lt, col_nat_dk, col_urb_lt, col_urb_dk, spread){
  
  #shape_urb<-mshape_urban.raw[]
  #shape_nat<-mshape_forest.raw[]
  #spread<- 1.5
  
  #This function is built color in our specimens, and so assumes our specific landmark structure
  #This could easily be changed to work with a different landmark structure
  #This function aligns the two specimens vertically using landmark 3 and 4
  
  #col_nat_lt assigns the lighter color of the left toepad
  #col_nat_dk assigns the darker color of the left toepad
  #col_urb_lt assigns the lighter color of the right toepad
  #col_urb_dk assigns the darker color of the right toepad
  
  # shift landmarks vertically to align landmark 3 and 4 with 0 on the Y axis
  #plot(shape_urb, asp=1)
  vert_shift<-0-mean(shape_urb[3:4,2])
  shape_urb[,2]<-shape_urb[,2]+vert_shift
  
  #plot(shape_nat, asp=1)
  vert_shift<-0-mean(shape_nat[3:4,2])
  shape_nat[,2]<-shape_nat[,2]+vert_shift
  
  
  #shift landmarks horizontally left and right of 0 on the x axis to set the distance between the specimens (+spread and -spread)
  
  #plot(shape_urb, asp=1)
  shape_urb[,1]<-shape_urb[,1]+spread
  
  #plot(shape_nat, asp=1)
  shape_nat[,1]<-shape_nat[,1]-spread
  
  
  #plot the shapes
  plot(x=c(shape_urb[,1], shape_nat[,1]), y=c(shape_urb[,2], shape_nat[,2]), asp=1, col="white", xlab=NA, ylab=NA, xaxt="n", yaxt="n", bty="n") #plot an empty plot with the correct dimensions 
  
  #add a grid to the background of the plot
  if (spread==1.5) {
    abline (v=c(seq(-5, 5, by=0.5)), col = "darkgrey", lty = "dotted")
    abline (h=c(seq(-10, 10, by=0.5)), col = "darkgrey", lty = "dotted")
  }
  if (spread==0.05) {
    abline (v=c(seq(-0.2, 0.2, by=0.02)), col = "darkgrey", lty = "dotted")
    abline (h=c(seq(-0.3, 0.3, by=0.02)), col = "darkgrey", lty = "dotted")
  }
  
  
  #alignment line showing the vertical alignment of landmarks 3 and 4
  segments(x0 = mean(shape_urb[3:4,1]), y0=0, x1=mean(shape_nat[3:4,1]), y1=0, lty=2)
  #plot lines showing the top of both pads (landmarks 7 and 8)
  segments(x0 = mean(shape_urb[7:8,1]), y0=mean(shape_urb[7:8,2]), x1=mean(shape_urb[7:8,1])-(2*spread), y1=mean(shape_urb[7:8,2]), lty=1, lwd=2, col=col_urb_lt)
  segments(x0 = mean(shape_nat[7:8,1]), y0=mean(shape_nat[7:8,2]), x1=mean(shape_nat[7:8,1])+(2*spread), y1=mean(shape_nat[7:8,2]), lty=1, lwd=2, col=col_nat_dk)
  
  outline_points<-c(1,20:27,3,28:35,5,36:43,7,44:51,9,52:59,8,60:67,6,68:75,4,76:83,2) #to define the outline of our toe
  pad_points<-c(3,28:35,5,36:43,7,8,60:67,6,68:75,4) #to define the outline of our pad
  lamellae_points1<-c(10, 84:91, 11) #to define the points of each lamellae curve
  lamellae_points2<-c(12, 92:99, 13)
  lamellae_points3<-c(14, 100:107, 15)
  lamellae_points4<-c(16, 108:115, 17)
  lamellae_points5<-c(18, 116:123, 19)
  
  polygon(shape_urb[outline_points,], border=NA, col=col_urb_lt)
  polygon(shape_urb[pad_points,], border=NA, col=col_urb_dk)
  points(shape_urb[1:9,], pch=19, cex=0.5)
  
  points(shape_urb[10:19,], pch=19, cex=0.2)
  points(shape_urb[lamellae_points1,], type = "l")
  points(shape_urb[lamellae_points2,], type = "l")
  points(shape_urb[lamellae_points3,], type = "l")
  points(shape_urb[lamellae_points4,], type = "l")
  points(shape_urb[lamellae_points5,], type = "l")
  
  
  ###shape nat
  polygon(shape_nat[outline_points,], border=NA, col=col_nat_lt)
  polygon(shape_nat[pad_points,], border=NA, col=col_nat_dk)
  points(shape_nat[1:9,], pch=19, cex=0.5)
  
  points(shape_nat[10:19,], pch=19, cex=0.2)
  points(shape_nat[lamellae_points1,], type = "l")
  points(shape_nat[lamellae_points2,], type = "l")
  points(shape_nat[lamellae_points3,], type = "l")
  points(shape_nat[lamellae_points4,], type = "l")
  points(shape_nat[lamellae_points5,], type = "l")
  
  
}



#This function produces a .pdf plot file comparing two shapes side by side. You must have a destination folder already in place to receive these .pdf plots
#I use the folder "Plots" within our "Output" folder in the to receive these plots  

#while we use standard gray colors for our urban shapes, 
#we use a specific green for part of our forest shapes 
darkgreen.cust<-"#008000"
lightgreen.cust<-"#3CB371"

#plot comparative shapes 
pdf(file = file.path("Output/Plots/mshape_forest-urban.pdf"), width=6, height=7)
par(mfrow=c(1,2), mar=c(3, 1, 4, 1))

Compare_shape(shape_urb = mshape.urban.raw, shape_nat = mshape.forest.raw, col_nat_lt = lightgreen.cust, col_nat_dk = darkgreen.cust, col_urb_lt="lightgray", col_urb_dk = "darkgray", spread = 1.5)
title(main="Pre-alignment Mean Shapes")

Compare_shape(shape_urb = mshape.urban.super, shape_nat = mshape.forest.super, col_nat_lt = lightgreen.cust, col_nat_dk = darkgreen.cust, col_urb_lt="lightgray", col_urb_dk = "darkgray", spread = 0.05)
title(main="Aligned Mean Shapes")

#make a custom legend
par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(2, 0, 3, 0), new=TRUE) #make new blank plot over our existing plot
plot(0,0, type='n', bty='n', xaxt='n', yaxt='n', xlab=NA, col=NA)

polygon(x=c(-0.2, -0.2, 0.2, 0.2), y=c(-0.8, -1.05, -1.05, -0.8), col="white", border=NA)

text(x=0.06, y=-0.88, "Forest", cex=1.2)
text(x=0.06, y=-0.98, "Urban", cex=1.2)

polygon(x=c(-0.06, -0.06, -0.14, -0.14), y=c(-0.84, -0.91, -0.91, -0.84), col=lightgreen.cust, border=NA)
polygon(x=c(-0.14, -0.14, -0.06), y=c(-0.84, -0.91, -0.91), col=darkgreen.cust, border=NA)

polygon(x=c(-0.06, -0.06, -0.14, -0.14), y=c(-0.94, -1.01, -1.01, -0.94), col="lightgrey", border=NA)
polygon(x=c(-0.14, -0.14, -0.06), y=c(-0.94, -1.01, -1.01), col="darkgray", border=NA)


dev.off()


#Since the interacton between habitat cagetory and municipality is significant, 
#the relationship between urban and forest is likely different for each municipality.
#Below, we compare pre and post aligned mean urban and forest shapes for each municipality separately. 


#run loop to plot municipality specific urban and forest means
for(m in levels(dat.field$Municipality)){
  #m<-"Aguadilla"
  sub.raw.forest<-dat.raw.vert[,,dat.field$Municipality==m & dat.field$Habitat_Category=="forest"] #get unaligned data for individuals in this municipality and forest habitats 
  sub.raw.urban<-dat.raw.vert[,,dat.field$Municipality==m & dat.field$Habitat_Category=="urban"] #get unaligned data for individuals in this municipality and urban habitats 
  
  sub.super.forest<-dat.super.vert[,,dat.field$Municipality==m & dat.field$Habitat_Category=="forest"] #get aligned data for individuals in this municipality and forest habitats 
  sub.super.urban<-dat.super.vert[,,dat.field$Municipality==m & dat.field$Habitat_Category=="urban"] #get aligned data for individuals in this municipality and urban habitats 
  
  mshape.urban.raw<-mshape(sub.raw.urban) #get the mean pre-alignment shape of urban lizards 
  mshape.forest.raw<-mshape(sub.raw.forest) #get the mean pre-alignment shape of forest lizards 
  
  mshape.urban.super<-mshape(sub.super.urban) #get the mean aligned shape of urban lizards 
  mshape.forest.super<-mshape(sub.super.forest) #get the mean aligned shape of forest lizards 
  

  #plot comparative shapes 
  
  pdf(file = file.path(paste("Output/Plots/mshape_urban-forest_", m, ".pdf", sep="")), width=6, height=7)
  par(mfrow=c(1,2), mar=c(3, 1, 4, 1))  
  
  Compare_shape(shape_urb = mshape.urban.raw, shape_nat = mshape.forest.raw, col_nat_lt = lightgreen.cust, col_nat_dk = darkgreen.cust, col_urb_lt="lightgray", col_urb_dk = "darkgray", spread = 1.5)
  title(main="Pre-alignment Mean Shapes")
  
  Compare_shape(shape_urb = mshape.urban.super, shape_nat = mshape.forest.super, col_nat_lt = lightgreen.cust, col_nat_dk = darkgreen.cust, col_urb_lt="lightgray", col_urb_dk = "darkgray", spread = 0.05)
  title(main="Aligned Mean Shapes")
  
  mtext(text = m, side = 3, outer=T, line=-1.5, adj=0.5, font=2, cex=1.3)
  
  #make a custom legend
  par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(2, 0, 3, 0), new=TRUE) #make new blank plot over our existing plot
  plot(0,0, type='n', bty='n', xaxt='n', yaxt='n', xlab=NA, col=NA)
  
  polygon(x=c(-0.2, -0.2, 0.2, 0.2), y=c(-0.8, -1.05, -1.05, -0.8), col="white", border=NA)
  
  text(x=0.06, y=-0.88, "Forest", cex=1.2)
  text(x=0.06, y=-0.98, "Urban", cex=1.2)
  
  polygon(x=c(-0.06, -0.06, -0.14, -0.14), y=c(-0.84, -0.91, -0.91, -0.84), col=lightgreen.cust, border=NA)
  polygon(x=c(-0.14, -0.14, -0.06), y=c(-0.84, -0.91, -0.91), col=darkgreen.cust, border=NA)
  
  polygon(x=c(-0.06, -0.06, -0.14, -0.14), y=c(-0.94, -1.01, -1.01, -0.94), col="lightgrey", border=NA)
  polygon(x=c(-0.14, -0.14, -0.06), y=c(-0.94, -1.01, -1.01), col="darkgray", border=NA)
  
  
  dev.off()
  
}

#remove variables from memory that we'll no longer need 
rm(fit)
rm(out)
rm(gdf)
rm(mshape.forest.raw)
rm(mshape.forest.super)
rm(mshape.urban.raw)
rm(mshape.urban.super)
rm(rot)
rm(template)
rm(m)
rm(s)
rm(sub.raw.forest)
rm(sub.raw.urban)
rm(sub.super.forest)
rm(sub.super.urban)

###### Canonical Variance Analysis (CVA) #####

## We also performed a canonical variance analysis (CVA). 
#this analysis is superficially similar to a principal component analyses, but instead of finding 
#axes of the most variation, a CVA finds axes that maximize the differences between provided groups 
#hence providing a more directed way to identifying and visualizing differences between groups, 
#which will be urban and forest lizards in our case 

library(Morpho)

#CVA
#perform CVA and test Mahalanobis distance between groups with permutation test)            
cvall<-CVA(dat.super$coords,dat.field$Habitat_Category)

#Since we only have 2 categories (urban or forest, we end up with 1 CV axis)
cvall$Var #percent variance explained by the CVA dimension 
#Should be 8.634839

#We can make our own better looking histogram 
#get the CV scores for urban and forest individuals
CVscores.forest<-cvall$CVscores[rownames(cvall$CVscores)=="forest",]
CVscores.urban<-cvall$CVscores[rownames(cvall$CVscores)=="urban",]

#make colors for plots 
transparnt.green<-"#00800080" #transparnt green

pdf(file=file.path("Output/Plots/CVAHistogram.pdf"), width=4, height = 4)
par(mar=c(0,3.5,0,1), pty="s") 

#get the category counts to determine the y axis limits
counts_urb<-hist(CVscores.urban, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7), plot = F)$counts
counts_nat<-hist(CVscores.forest, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7), plot = F)$counts
counts<-max(c(counts_urb, counts_nat))+1 #I added one here to make sure the bars don't hit the top of the plot

hist(CVscores.urban, col="lightgray", breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7), ylim=c(0,counts), main=NA, xlab=NA, ylab=NA, xaxt="n", yaxt="n")
mtext("Canonical Axis", side=1, line=0, cex=1.5)
mtext("Count", side=2, line=1.5, cex=1.5)
axis(side = 2, at = seq(from=0, to=counts, by=10), line= -0.55)

hist(CVscores.forest, add=T, col=transparnt.green, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7))

legend("topleft", legend=c("Forest Lizards", "Urban Lizards"), fill=c(transparnt.green, "lightgrey"), bty="n", border="black")

dev.off() 


## visualize a shape change from score -7 to 7:
cvvis7 <-     7*matrix(cvall$CVvis[,1],nrow(cvall$Grandm),ncol(cvall$Grandm))+cvall$Grandm
cvvisNeg7 <- -7*matrix(cvall$CVvis[,1],nrow(cvall$Grandm),ncol(cvall$Grandm))+cvall$Grandm

#rotate the projected shapes to be vertical 
cvvis7<-rotate.coords(cvvis7, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise
cvvisNeg7<-rotate.coords(cvvisNeg7, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise


pdf(file = file.path("Output/Plots/CVA_extremes.pdf"))

Compare_shape(shape_nat = cvvisNeg7, shape_urb = cvvis7, col_nat_lt = lightgreen.cust, col_nat_dk = darkgreen.cust, col_urb_lt = "lightgray", col_urb_dk = "darkgray", spread = 0.05)
title(main="CVA Extremes")

polygon(x=c(-0.1, -0.1, 0.1, 0.1), y=c(-0.3, -0.27, -0.27, -0.3), col="white", border=NA)
text("Minimum", x=-0.05, y=-0.28, xpd=T, cex=1.2, bg="white")
text("Maximum", x=0.05, y=-0.28, xpd=T, cex=1.2)


dev.off()

#lastly, we must consider our CVA historgram in context of what is to be expected.
#Since CVA finds axes that maximize differences bewtween groups, and since our data is so highly dimentional and we're only considering 2 groups
#we expect by chance, even with randomized groups, that there will be axes that seperate the groups well by chance. 

#To investigate this we can randomize our habitat category variable, and then perform repeated CVA's and see how seperated the resulting histograms are
#We are producing 100 randommized datasets to visuzlize how similar we expect a CVA histogram to by by chance

CV_gray<-rgb(t(col2rgb("lightgray"))/255, alpha = 0.5)
CV_green<-rgb(t(col2rgb("mediumseagreen"))/255, alpha = 0.5)

#randomize the habitat category variable 100 times and pull out the histogram counts 
random_hab <- vector(mode = "list", length = 100) #will store 100 randomized hatibiat assignments 
hist_counts_min<-vector(mode = "list", length = 15) #will store the histogram heights for 15 bins (-7 to +7) for the min groups
hist_counts_max<-vector(mode = "list", length = 15) #will store the histogram heights for 15 bins (-7 to +7) for the max groups

rand_num<-as.factor(sample(0:1, (246*100), replace=T)) #simulate all the data

CV_rand_deltaMeans<-rep(NA, 100)

for(r in 1:100){
  #r<-100
  random_hab[[r]]<-rand_num[(((r-1)*246)+1):(r*246)] #cut the random numbers into repeated trials
  
  cvall.random<-CVA(dat.super$coords, random_hab[[r]], plot=F) #fit a CVA to our current shapes, but wth each individaul randomly assigned to a habitat category 
  
  #group categories that were categorized below 0 or above 0 
  CVscores.rando_0<-cvall.random$CVscores[rownames(cvall.random$CVscores)=="0",]
  CVscores.rando_1<-cvall.random$CVscores[rownames(cvall.random$CVscores)=="1",]
  if(mean(CVscores.rando_0) < mean(CVscores.rando_1)){
    CVscores.rando_min<-CVscores.rando_0
    CVscores.rando_max<-CVscores.rando_1
  }
  if(mean(CVscores.rando_0) > mean(CVscores.rando_1)){
    CVscores.rando_min<-CVscores.rando_1
    CVscores.rando_max<-CVscores.rando_0
  }
  
  #extract hist counts 
  histmin_out<-hist(CVscores.rando_min, plot=F, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7))
  histmax_out<-hist(CVscores.rando_max, plot=F, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7))
  
  CV_rand_deltaMeans[r]<-mean(CVscores.rando_max)-mean(CVscores.rando_min)
  
  #seperate hist counts by bin
  for (b in 1:15){
    #b<-1
    hist_counts_min[[b]]<-c(hist_counts_min[[b]], histmin_out$counts[b])
    hist_counts_max[[b]]<-c(hist_counts_max[[b]], histmax_out$counts[b])
  }
  
}

#how different, on average, were the means of the two randomly assigned categories?
mean(CV_rand_deltaMeans) #4.277738 (for our run included in paper)
sd(CV_rand_deltaMeans) #0.4691378 (for our run included in paper)
max(CV_rand_deltaMeans) #5.812394 (for our run included in paper)

#Comapred to the difference in our actual data 
mean(CVscores.urban)-mean(CVscores.forest) #5.886048

#Make plot of shaded region of 2 standard deviations around the average random trial 
hist_counts_min_ave<-lapply(X=hist_counts_min, FUN = mean)
hist_counts_max_ave<-lapply(X=hist_counts_max, FUN = mean)

#get 2 standard deviations intervals around each bin average 
hist_counts_min_2SD<-lapply(X=hist_counts_min, FUN = sd)
hist_counts_min_2SD<-lapply(X=hist_counts_min_2SD, FUN = function (x) 1.96*x)

hist_counts_max_2SD<-lapply(X=hist_counts_max, FUN = sd)
hist_counts_max_2SD<-lapply(X=hist_counts_max_2SD, FUN = function (x) 1.96*x)

#calculate upper and lower bounds for each bin
min_bounds<-matrix(nrow = 15, ncol = 2)
max_bounds<-matrix(nrow = 15, ncol = 2)

colnames(min_bounds)<-c("lower", "upper")
colnames(max_bounds)<-c("lower", "upper")

min_bounds[,"lower"]<-unlist(hist_counts_min_ave)-unlist(hist_counts_min_2SD)
min_bounds[,"upper"]<-unlist(hist_counts_min_ave)+unlist(hist_counts_min_2SD)

max_bounds[,"lower"]<-unlist(hist_counts_max_ave)-unlist(hist_counts_max_2SD)
max_bounds[,"upper"]<-unlist(hist_counts_max_ave)+unlist(hist_counts_max_2SD)


pdf(file=file.path("Output/Plots/CVAHistogram_randomized.pdf"), width=4, height = 4)
par(mar=c(0,3.5,0,1), pty="s") 

plot(x=1:15, y=1:15, col="white", xaxt="n", yaxt="n", ylim=c(0, 70), xlab=NA, ylab=NA)
mtext("Canonical Axis", side=1, line=1, cex=1.5)
mtext("Count", side=2, line=2, cex=1.5)
axis(side = 2, at = seq(from=0, to=70, by=10))

#random variation polygon
polygon(x=c(1:14,14:1), y=c(min_bounds[1:14,"lower"], min_bounds[14:1,"upper"]), col=CV_green, border = NA)
polygon(x=c(1:14,14:1), y=c(max_bounds[1:14,"lower"], max_bounds[14:1,"upper"]), col=CV_gray, border = NA)

legend("topleft", legend=c("Forest Lizards", "Urban Lizards"), fill=c("darkgreen", "lightgrey"), bty="n", border="black")


#add points of our actual CVA results 
points(x=1:14, y=hist(CVscores.urban, plot=F, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7))$counts, pch=19, col="dimgrey", cex=0.5, type="l", lwd=2)
points(x=1:14, y=hist(CVscores.forest, plot=F, breaks=c(-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7))$counts, pch=19, col="forestgreen", cex=0.5, type="l", lwd=2)

dev.off()

#Your plots will be unique, but by using random data, we can still see a distinction between the groups, noting that the distinction is wider in our real data


#remove variables we no longer need 
rm(cvall)
rm(cvall.random)
rm(cvvis7)
rm(cvvisNeg7)
rm(counts)
rm(counts_nat)
rm(counts_urb)
rm(CVscores.forest)
rm(CVscores.urban)
rm(CV_gray)
rm(CV_green)
rm(CVscores.rando_0)
rm(CVscores.rando_1)
rm(CVscores.rando_min)
rm(CVscores.rando_max)
rm(r)
rm(hist_counts_max)
rm(hist_counts_max_2SD)
rm(hist_counts_max_ave)
rm(hist_counts_min)
rm(hist_counts_min_2SD)
rm(hist_counts_min_ave)
rm(histmax_out)
rm(histmin_out)
rm(max_bounds)
rm(min_bounds)
rm(b)
rm(rand_num)
rm(random_hab)


###### Principal Component Analyses (PCA) ######
#A principal component analysis (PCA) allows us to investigate the primary axes of variation in our shape data,
#rotating and plotting our data along axes that capture the most variation in our data 

#extract PC info
PCAdat<-gm.prcomp(dat.super$coords) #plotTangentSpace deprecated in geomoprh version 3.3.1

PCscores<-PCAdat$x #PC scores represent each specimen's location on each PC axes

##Plot PC axes with urban and forest means for each municipality
#We first need to calculate urban and forest means for each municipality for each PC axis 1-3
PCA.muni.averages<-mat.or.vec(nr=length(levels(dat.field$Municipality))*2, nc=3) #make an empty matrix with a row for each municipality * 2 (for urban and forest) and 3 columns for PCA 1-3
rownames(PCA.muni.averages)<-sort(c(paste(levels(dat.field$Municipality), "urban", sep="_"), paste(levels(dat.field$Municipality), "forest", sep="_"))) #make all the municipality-habitat combinations to name the rows 
colnames(PCA.muni.averages)<-c("PC1", "PC2", "PC3")

for (m in levels(dat.field$Municipality)){ #loop through each municipality to calculate the urban and forest PC 1-3 average
  #m<-"Aguadilla"
  muni.forest<-PCscores[dat.field$Municipality==m & dat.field$Habitat_Category=="forest",1:3] #get columns 1-3 of rows in PCscores data that are individuals in this municipality and are forest
  muni.urban<-PCscores[dat.field$Municipality==m & dat.field$Habitat_Category=="urban",1:3] #get columns 1-3 of rows in PCscores data that are individuals in this municipality and are urban
  
    PCA.muni.averages[paste(m, "forest", sep="_"), ]<-apply(muni.forest, 2, mean) #calculate the means for PC 1-3 and add it to the approperaite row
    PCA.muni.averages[paste(m, "urban", sep="_"), ]<-apply(muni.urban, 2, mean) #calculate the means for PC 1-3 and add it to the approperaite row
}

#make a object that is a list of colors to dictate which points will be which colors 
col.list<-as.character(dat.field$Habitat_Category)
col.list[col.list=="forest"]<-"#00800080" #transparnt green
col.list[col.list=="urban"]<-"#BEBEBE80" #transparant grey

#I am depositing our PCA plots into a file named "P123" within our "Plots" folder

#### PC 1, 2 and 3 plots
pdf(file=file.path("Output/Plots/PC123.pdf"), width=7, height = 5)
par(mfrow=c(1,2), mar=c(3,3,5,1), pty="s") 

plot(PCscores[,"Comp1"], PCscores[,"Comp2"], pch=19, xlab=NA, ylab=NA, xaxt="n", yaxt="n", col=col.list)
mtext("Principal Component\nAxis 1", side=1, line=2, cex=1.5)
mtext("Principal Component\nAxis 2", side=2, line=0.2, cex=1.5)

#plot convex hull around urban and forest points 
hpts<-chull(PCscores[col.list=="#00800080", 1], y = PCscores[col.list=="#00800080", 2]) #get list of outer forest points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(PCscores[col.list=="#00800080", 1][hpts], PCscores[col.list=="#00800080", 2][hpts], col=lightgreen.cust) #plot the lines

hpts<-chull(PCscores[col.list=="#BEBEBE80", 1], y = PCscores[col.list=="#BEBEBE80", 2]) #get list of outer forest points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(PCscores[col.list=="#BEBEBE80", 1][hpts], PCscores[col.list=="#BEBEBE80", 2][hpts], col="gray") #plot the lines


#add averages for each municipality with a line segment connecting urban to forest
segments(PCA.muni.averages["Aguadilla_urban", 1], PCA.muni.averages["Aguadilla_urban", 2], PCA.muni.averages["Aguadilla_forest", 1], PCA.muni.averages["Aguadilla_forest", 2])
points(PCA.muni.averages["Aguadilla_urban", 1], PCA.muni.averages["Aguadilla_urban", 2], bg="grey", col="black", pch=24)
points(PCA.muni.averages["Aguadilla_forest", 1], PCA.muni.averages["Aguadilla_forest", 2], bg=darkgreen.cust, col="black", pch=24)

segments(PCA.muni.averages["Arecibo_urban", 1], PCA.muni.averages["Arecibo_urban", 2], PCA.muni.averages["Arecibo_forest", 1], PCA.muni.averages["Arecibo_forest", 2])
points(PCA.muni.averages["Arecibo_urban", 1], PCA.muni.averages["Arecibo_urban", 2], bg="grey", col="black", pch=23)
points(PCA.muni.averages["Arecibo_forest", 1], PCA.muni.averages["Arecibo_forest", 2], bg=darkgreen.cust, col="black", pch=23)

segments(PCA.muni.averages["Mayaguez_urban", 1], PCA.muni.averages["Mayaguez_urban", 2], PCA.muni.averages["Mayaguez_forest", 1], PCA.muni.averages["Mayaguez_forest", 2])
points(PCA.muni.averages["Mayaguez_urban", 1], PCA.muni.averages["Mayaguez_urban", 2], bg="grey", col="black", pch=21)
points(PCA.muni.averages["Mayaguez_forest", 1], PCA.muni.averages["Mayaguez_forest", 2], bg=darkgreen.cust, col="black", pch=21)

segments(PCA.muni.averages["Ponce_urban", 1], PCA.muni.averages["Ponce_urban", 2], PCA.muni.averages["Ponce_forest", 1], PCA.muni.averages["Ponce_forest", 2])
points(PCA.muni.averages["Ponce_urban", 1], PCA.muni.averages["Ponce_urban", 2], bg="grey", col="black", pch=22)
points(PCA.muni.averages["Ponce_forest", 1], PCA.muni.averages["Ponce_forest", 2], bg=darkgreen.cust, col="black", pch=22)

segments(PCA.muni.averages["San Juan_urban", 1], PCA.muni.averages["San Juan_urban", 2], PCA.muni.averages["San Juan_forest", 1], PCA.muni.averages["San Juan_forest", 2])
points(PCA.muni.averages["San Juan_urban", 1], PCA.muni.averages["San Juan_urban", 2], bg="grey", col="black", pch=25)
points(PCA.muni.averages["San Juan_forest", 1], PCA.muni.averages["San Juan_forest", 2], bg=darkgreen.cust, col="black", pch=25)


par(xpd=TRUE)
legend(-0.10,0.13, pch=c(24,23,21,22,25), legend=rep("", 5), pt.bg=darkgreen.cust, bty="n", cex=0.8)
legend(-0.09,0.13, pch=c(24,23,21,22,25), pt.bg="grey", legend=c("Aguadilla", "Arecibo", "Mayaguez", "Ponce", "San Juan"), bty="n", cex=0.8)
text(-0.083,0.13, "Forest", cex=0.8, pos=2)
text(-0.055,0.13, "Urban", cex=0.8, pos=2)



plot(PCscores[,"Comp2"], PCscores[,"Comp3"], pch=19, xlab=NA, ylab=NA, xaxt="n", yaxt="n", col=col.list)
mtext("Principal Component\nAxis 2", side=1, line=2, cex=1.5)
mtext("Principal Component\nAxis 3", side=2, line=0.2, cex=1.5)


#plot convex hull around urban and forest points 
hpts<-chull(PCscores[col.list=="#00800080", 2], y = PCscores[col.list=="#00800080", 3]) #get list of outer forest points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(PCscores[col.list=="#00800080", 2][hpts], PCscores[col.list=="#00800080", 3][hpts], col=lightgreen.cust) #plot the lines

hpts<-chull(PCscores[col.list=="#BEBEBE80", 2], y = PCscores[col.list=="#BEBEBE80", 3]) #get list of outer forest points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(PCscores[col.list=="#BEBEBE80", 2][hpts], PCscores[col.list=="#BEBEBE80", 3][hpts], col="gray") #plot the lines

#add averages for each municipality with a line segment connecting urban to forest
segments(PCA.muni.averages["Aguadilla_urban", 2], PCA.muni.averages["Aguadilla_urban", 3], PCA.muni.averages["Aguadilla_forest", 2], PCA.muni.averages["Aguadilla_forest", 3])
points(PCA.muni.averages["Aguadilla_urban", 2], PCA.muni.averages["Aguadilla_urban", 3], bg="grey", col="black", pch=24)
points(PCA.muni.averages["Aguadilla_forest", 2], PCA.muni.averages["Aguadilla_forest", 3], bg=darkgreen.cust, col="black", pch=24)

segments(PCA.muni.averages["Arecibo_urban", 2], PCA.muni.averages["Arecibo_urban", 3], PCA.muni.averages["Arecibo_forest", 2], PCA.muni.averages["Arecibo_forest", 3])
points(PCA.muni.averages["Arecibo_urban", 2], PCA.muni.averages["Arecibo_urban", 3], bg="grey", col="black", pch=23)
points(PCA.muni.averages["Arecibo_forest", 2], PCA.muni.averages["Arecibo_forest", 3], bg=darkgreen.cust, col="black", pch=23)

segments(PCA.muni.averages["Mayaguez_urban", 2], PCA.muni.averages["Mayaguez_urban", 3], PCA.muni.averages["Mayaguez_forest", 2], PCA.muni.averages["Mayaguez_forest", 3])
points(PCA.muni.averages["Mayaguez_urban", 2], PCA.muni.averages["Mayaguez_urban", 3], bg="grey", col="black", pch=21)
points(PCA.muni.averages["Mayaguez_forest", 2], PCA.muni.averages["Mayaguez_forest", 3], bg=darkgreen.cust, col="black", pch=21)

segments(PCA.muni.averages["Ponce_urban", 2], PCA.muni.averages["Ponce_urban", 3], PCA.muni.averages["Ponce_forest", 2], PCA.muni.averages["Ponce_forest", 3])
points(PCA.muni.averages["Ponce_urban", 2], PCA.muni.averages["Ponce_urban", 3], bg="grey", col="black", pch=22)
points(PCA.muni.averages["Ponce_forest", 2], PCA.muni.averages["Ponce_forest", 3], bg=darkgreen.cust, col="black", pch=22)

segments(PCA.muni.averages["San Juan_urban", 2], PCA.muni.averages["San Juan_urban", 3], PCA.muni.averages["San Juan_forest", 2], PCA.muni.averages["San Juan_forest", 3])
points(PCA.muni.averages["San Juan_urban", 2], PCA.muni.averages["San Juan_urban", 3], bg="grey", col="black", pch=25)
points(PCA.muni.averages["San Juan_forest", 2], PCA.muni.averages["San Juan_forest", 3], bg=darkgreen.cust, col="black", pch=25)

dev.off()



#We can also determine and plot the amount of variation each PC axes captures  
invisible(capture.output(out<-summary(PCAdat))) 
out$PC.summary[2,1:3] #Variation captured per axis for axes 1-3
out$PC.summary[3,1:3] #cummulative variation captured for axis for axes 1-3


pdf(file=file.path("Output/Plots/PCA variation barplot.pdf"))
par(mar=c(3,5,4,5)) 
bar.out<-barplot(as.matrix(out$PC.summary[3,1:3]), cex.axis=2.5, ylim=c(0,1), ylab=NA, names.arg=c(NA,NA,NA), cex.lab=2.5, col="gray")
axis(side=1, labels = NA, at=c(0, 10))
axis(side=1, labels = c("PC1", "PC2", "PC3"), at=bar.out, cex.axis=2.5, line=1, tick=F)
mtext("Cumulative Proportion\nof Variation", side = 3, cex = 2.5, line=-3)

dev.off()



#We can also plot the estimated shapes that each PC axis extreme represents 
#We are using the same Compare_shape() function as we used above to plot compare urban and forest shapes
#even though in this instance we are comparing PC minimum and maximum shape projections, the function works the same

#need to rotate each projection 90deg to face upwards
PC1min<-rotate.coords(PCAdat$shapes$shapes.comp1$min, type = "rotateCC") 
PC1max<-rotate.coords(PCAdat$shapes$shapes.comp1$max, type = "rotateCC") 
PC2min<-rotate.coords(PCAdat$shapes$shapes.comp2$min, type = "rotateCC") 
PC2max<-rotate.coords(PCAdat$shapes$shapes.comp2$max, type = "rotateCC")
PC3min<-rotate.coords(PCAdat$shapes$shapes.comp3$min, type = "rotateCC") 
PC3max<-rotate.coords(PCAdat$shapes$shapes.comp3$max, type = "rotateCC") 


#plot comparative shapes 
pdf(file = file.path("Output/Plots/PCextremes.pdf"))
par(mfrow=c(1,3), mar=c(8,1,1,1))

Compare_shape(shape_nat = PC1min, shape_urb = PC1max, col_nat_lt = "tan", col_nat_dk = "burlywood4", col_urb_lt = "tan", col_urb_dk = "burlywood4", spread = 0.05)
legend(x=-0.03, y=-0.28, legend="    PC 1\nMaximum", bg = "white", cex=2, bty = "o", box.col="white", xpd=T)
legend(x=-0.13,y=-0.28, legend="   PC 1\nMinimum", bg = "white", cex=2, bty = "o", box.col="white", xpd=T)

Compare_shape(shape_nat = PC2min, shape_urb = PC2max, col_nat_lt = "tan", col_nat_dk = "burlywood4", col_urb_lt = "tan", col_urb_dk = "burlywood4", spread = 0.05)
legend(x=-0.02, y=-0.27, legend="    PC 2\nMaximum", bg = "white", cex=2, bty = "o", box.col="white", xpd=T)
legend(x=-0.13,y=-0.27, legend="   PC 2\nMinimum", bg = "white", cex=2, bty = "o", box.col="white", xpd=T)

Compare_shape(shape_nat = PC3min, shape_urb = PC3max, col_nat_lt = "tan", col_nat_dk = "burlywood4", col_urb_lt = "tan", col_urb_dk = "burlywood4", spread = 0.05)
legend(x=-0.03, y=-0.29, legend="    PC 3\nMaximum", bg = "white", cex=2, bty = "o", box.col="white", xpd=T)
legend(x=-0.13,y=-0.29, legend="   PC 3\nMinimum", bg = "white", cex=2, bty = "o", box.col="white", xpd=T)

dev.off()


#PCA plots for each muninicapality 


pdf(file=file.path("Output/Plots/PC123_Municipality.pdf"), width=7, height=18)
par(mfrow=c(5,2), mar=c(5,5,2,0.5), pty="s")


for(muni in levels(dat.field$Municipality)){
  #muni<-"Aguadilla"
  wh<-which(dat.field$Municipality==muni)
  

  #PC1 vs 2
  plot(PCscores[wh,"Comp1"], PCscores[wh,"Comp2"], pch=19, xlim=c(-0.1, 0.1), ylim=c(-0.07, 0.07), xlab=NA, ylab=NA, xaxt="n", yaxt="n", col=col.list[wh], main=muni)
  mtext("Principal Component\nAxis 1", side=1, line=3, cex=1.5)
  mtext("Principal Component\nAxis 2", side=2, line=0.2, cex=1.5)
  
  #plot convex hull around urban and forest points 
  hpts<-chull(PCscores[dat.field$Municipality==muni & col.list=="#00800080", 1], y = PCscores[dat.field$Municipality==muni & col.list=="#00800080", 2]) #get list of outer forest points
  hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
  lines(PCscores[dat.field$Municipality==muni & col.list=="#00800080", 1][hpts], PCscores[dat.field$Municipality==muni & col.list=="#00800080", 2][hpts], col=lightgreen.cust) #plot the lines
  
  hpts<-chull(PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 1], y = PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 2]) #get list of outer forest points
  hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
  lines(PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 1][hpts], PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 2][hpts], col="gray") #plot the lines
  
  #add averages with a line segment connecting urban to forest
  segments(mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 1]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 2]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 1]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 2]))
  points(mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 1]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 2]), bg="grey", col="black", pch=24)
  points(mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 1]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 2]), bg=darkgreen.cust, col="black", pch=24)
  
  
  #PC2 vs 3
  plot(PCscores[wh,"Comp2"], PCscores[wh,"Comp3"], pch=19, xlim=c(-0.1, 0.1), ylim=c(-0.07, 0.07), xlab=NA, ylab=NA, xaxt="n", yaxt="n", col=col.list[wh], main=muni)
  mtext("Principal Component\nAxis 2", side=1, line=3, cex=1.5)
  mtext("Principal Component\nAxis 3", side=2, line=0.2, cex=1.5)
  
  #plot convex hull around urban and forest points 
  hpts<-chull(PCscores[dat.field$Municipality==muni & col.list=="#00800080", 2], y = PCscores[dat.field$Municipality==muni & col.list=="#00800080", 3]) #get list of outer forest points
  hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
  lines(PCscores[dat.field$Municipality==muni & col.list=="#00800080", 2][hpts], PCscores[dat.field$Municipality==muni & col.list=="#00800080", 3][hpts], col=lightgreen.cust) #plot the lines
  
  hpts<-chull(PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 2], y = PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 3]) #get list of outer forest points
  hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
  lines(PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 2][hpts], PCscores[dat.field$Municipality==muni & col.list=="#BEBEBE80", 3][hpts], col="gray") #plot the lines
  
  #add averages with a line segment connecting urban to forest
  segments(mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 2]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 3]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 2]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 3]))
  points(mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 2]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="urban", 3]), bg="grey", col="black", pch=24)
  points(mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 2]), mean(PCscores[dat.field$Municipality==muni & dat.field$Habitat_Category=="forest", 3]), bg=darkgreen.cust, col="black", pch=24)

  
}

dev.off()



#remove variables from memory that we'll no longer need 
rm(muni.forest)
rm(muni.urban)
rm(out)
rm(PC1max)
rm(PC1min)
rm(PC2max)
rm(PC2min)
rm(PC3max)
rm(PC3min)
rm(PCA.muni.averages)
rm(PCAdat)
rm(PCscores)
rm(bar.out)
rm(hpts)
rm(m)


###### Between Group PCA ####
## A between group PCA is similar to a tradiitonal PCA in that it finds axes that capture the most variation,
# but instead of considering variation across the indiviudals in our dataset, between group PCA finds the most descriptvie axes across provided group means. 

library(Morpho)

gPCA_out<-groupPCA(dat.super$coords, groups=dat.field$Habitat_Category)
gPCA_out$probs #pval of pairwise group differences. should be p < 0.001

#Since we only had 2 categories (urban or forest), we ended up with a bgPCA with a single PC axis, which we can visualize with a histogram

#make a transparant grey color object
grey.transparant<-col2rgb("darkgrey")/255
grey.transparant<-rgb(t(grey.transparant), alpha = 0.5)


pdf(file=file.path("Output/Plots/bgPCA_Habitat_Category.pdf"), width=4, height=4)
par(mar=c(0,3.5,0,1), pty="s") 

hist(gPCA_out$Scores, border = "white", xaxt="n", xlab=NA, ylab=NA, main=NA, ylim=c(0, 35))
mtext("Between Group PCA Axis", side=1, line=0, cex=1.5)
mtext("Count", side=2, line=2, cex=1.5)

hist(gPCA_out$Scores[gPCA_out$groups=="forest"], col=darkgreen.cust, add=T)
hist(gPCA_out$Scores[gPCA_out$groups=="urban"], col=grey.transparant, add=T)

legend("topright", legend=c("Forest Lizards", "Urban Lizards"), fill=c(darkgreen.cust, grey.transparant), bty="n", border="black")

dev.off()



## visulize projected shape for the min and max of our single bgPC axis. 
proj.shape.2sd<- showPC(2*sd(gPCA_out$Scores[,1]), gPCA_out$groupPCs, gPCA_out$Grandmean)
proj.shape.2sd.neg<- showPC(-2*sd(gPCA_out$Scores[,1]), gPCA_out$groupPCs, gPCA_out$Grandmean)


proj.shape.2sd.neg<-rotate.coords(proj.shape.2sd.neg, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise
proj.shape.2sd<-rotate.coords(proj.shape.2sd, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise

pdf(file = file.path("Output/Plots/bgPCA_Habitat_extremes.pdf"))
Compare_shape(shape_nat = proj.shape.2sd.neg, shape_urb = proj.shape.2sd, col_urb_lt = lightgreen.cust, col_urb_dk = darkgreen.cust, col_nat_lt = "lightgray", col_nat_dk = "darkgray", spread = 0.05)
mtext(side = 1, text = "Minimum", line = -0.5, cex=1.2, at=c(-0.05))
mtext(side = 1, text = "Maximum", line = -0.5, cex=1.2, at=c(0.05))
dev.off()


#We can also extract how much of the total variation our first PC axis 
gPCA_out$combinedVar["bgPC_1", "cumVar"] #should be 0.040052

#Just for a sanity check, we can also randomize our habitat variable to assure the pattern we're seeing in our bgPCA histogram is meaningful and not produced by chance
#Produce a random habitat dataset
eco_random<-sample(1:2,length(dat.field$Habitat_Category),replace=T)
eco_random[eco_random==1]<-"forest"
eco_random[eco_random==2]<-"urban"
eco_random<-as.factor(eco_random)

gPCA_out.r<-groupPCA(dat.super$coords, groups=eco_random)
gPCA_out.r$probs #should not be sig because its random data

#plot the randomized habitat data 
hist(gPCA_out.r$Scores, border = "white", xaxt="n", xlab=NA, ylab=NA, main=NA, ylim=c(0,70))
mtext("Between Group PCA Axis", side=1, line=0, cex=1.5)
mtext("Count", side=2, line=2, cex=1.5)

hist(gPCA_out.r$Scores[gPCA_out.r$groups=="urban"], col=darkgreen.cust, add=T)
hist(gPCA_out.r$Scores[gPCA_out.r$groups=="forest"], col=grey.transparant, add=T)

legend("topright", legend=c("Forest Lizards", "Urban Lizards"), fill=c(darkgreen.cust, grey.transparant), bty="n", border="black")

#histograms should greatly overlap



## We can also perform a bgPCA using muni as our category to see how shape varies across municipalities

gPCA_out<-groupPCA(dat.super$coords, groups=dat.field$Municipality)
gPCA_out$probs 
#can see that all the municipalities are significanlty different from each other except San Juan and Mayaguez

#We can also extract how much of the total variation our first two PC axes 
gPCA_out$combinedVar[1:2, "cumVar"] #should be 0.1195264 for bgPC1 and 0.1827884 for PC1+PC2


#Since we only had 5 muni categories, we ended up with a bgPCA with 4 PC axis. We're only looking at PC1 and PC2
pdf(file=file.path("Output/Plots/bgPCA_Municipality.pdf"), width=5, height=5)

#in order to get an idea of what the axes should be.. 
#min(gPCA_out$Scores[,1])   pc1 min = -0.1
#max(gPCA_out$Scores[,1])   pc1 max =  0.1
#min(gPCA_out$Scores[,2])   pc2 min = -0.1
#max(gPCA_out$Scores[,2])   pc2 max =  0.1

par(mar=c(5,5,1,1))
plot(gPCA_out$Scores[,1], gPCA_out$Scores[,2], col="white", xaxt="n", yaxt="n", xlab=NA, ylab=NA, ylim=c(-0.1, 0.1), xlim=c(-0.1, 0.1))
mtext("Between Group\n Principal Component 1", side=1, line=2, cex=1.5)
mtext("Between Group\n Principal Component 2", side=2, line=0.2, cex=1.5)

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=24)
points(mean.urban, bg="darkgrey", pch=24)

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=23)
points(mean.urban, bg="darkgrey", pch=23)

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=21)
points(mean.urban, bg="darkgrey", pch=21)

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=22)
points(mean.urban, bg="darkgrey", pch=22)

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=25)
points(mean.urban, bg="darkgrey", pch=25)


legend(0.04,-0.055, pch=c(24,23,21,22,25), legend=rep("", 5), pt.bg=darkgreen.cust, bty="n", cex=0.8)
legend(0.05,-0.055, pch=c(24,23,21,22,25), pt.bg="grey", legend=c("Aguadilla", "Arecibo", "Mayaguez", "Ponce", "San Juan"), bty="n", cex=0.8)
text(0.055,-0.055, "Forest", cex=0.8, pos=2)
text(0.08,-0.055, "Urban", cex=0.8, pos=2)

dev.off() 



## visulize projected shape for the min and max of two bgPC axes. 
bgPC1.shape.2sd<- showPC(2*sd(gPCA_out$Scores[,1]), gPCA_out$groupPCs[,1], gPCA_out$Grandmean)
bgPC1.shape.2sd.neg<- showPC(-2*sd(gPCA_out$Scores[,1]), gPCA_out$groupPCs[,1], gPCA_out$Grandmean)

bgPC2.shape.2sd<- showPC(2*sd(gPCA_out$Scores[,2]), gPCA_out$groupPCs[,2], gPCA_out$Grandmean)
bgPC2.shape.2sd.neg<- showPC(-2*sd(gPCA_out$Scores[,2]), gPCA_out$groupPCs[,2], gPCA_out$Grandmean)

bgPC1.shape.2sd<-rotate.coords(bgPC1.shape.2sd, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise
bgPC1.shape.2sd.neg<-rotate.coords(bgPC1.shape.2sd.neg, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise
bgPC2.shape.2sd<-rotate.coords(bgPC2.shape.2sd, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise
bgPC2.shape.2sd.neg<-rotate.coords(bgPC2.shape.2sd.neg, type = "rotateCC") # the argument rotateCC rotates each matrix 90 deg counter clockwise

pdf(file = file.path("Output/Plots/bgPCA_Muni_extremes.pdf"), width=5, height=7)
par(mfrow=c(1,2), mar=c(8,1,1,0.5))

Compare_shape(shape_nat = bgPC1.shape.2sd.neg, shape_urb = bgPC1.shape.2sd, col_urb_lt = "tan", col_urb_dk = "burlywood4", col_nat_lt = "tan", col_nat_dk = "burlywood4", spread = 0.05)
mtext(side = 1, text = "PC 1 Minimum", line = -0.5, cex=0.8, at=c(-0.05))
mtext(side = 1, text = "PC 1 Maximum", line = -0.5, cex=0.8, at=c(0.05))

Compare_shape(shape_nat = bgPC2.shape.2sd.neg, shape_urb = bgPC2.shape.2sd, col_urb_lt = "tan", col_urb_dk = "burlywood4", col_nat_lt = "tan", col_nat_dk = "burlywood4", spread = 0.05)
mtext(side = 1, text = "PC 2 Minimum", line = -0.5, cex=0.8, at=c(-0.05))
mtext(side = 1, text = "PC 2 Maximum", line = -0.5, cex=0.8, at=c(0.05))

dev.off()




# make a plot for each municipality with green/grey points, with the same margins

#make colors for background points 
transparnt.green<-"#00800080" #transparnt green

# make plots
pdf(file=file.path("Output/Plots/bgPCA_Municipality_sep.pdf"), width=10, height=3)
par(mfrow=c(1,5), mar=c(4,3,2,0.5), pty="s")


#Aguadilla
forest.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="forest",1], gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="forest",2])
urban.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="urban",1], gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="urban",2])

plot(forest.pts, bg=transparnt.green, col=NA, pch=24, xaxt="n", yaxt="n", xlab=NA, ylab=NA, ylim=c(-0.1, 0.1), xlim=c(-0.1, 0.1))
points(urban.pts, bg=grey.transparant, col=NA, pch=24)
mtext("bgPC 1", side=1, line=1, cex=1)
mtext("bgPC 2", side=2, line=0.2, cex=1)
mtext("Aguadilla", side=3, line=0.5, font=2, cex=1)

hpts<-chull(forest.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(forest.pts[hpts,], col=transparnt.green) #plot the lines

hpts<-chull(urban.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(urban.pts[hpts,], col=grey.transparant) #plot the lines

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Aguadilla" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=24)
points(mean.urban, bg="darkgrey", pch=24)


#Arecibo
forest.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="forest",1], gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="forest",2])
urban.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="urban",1], gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="urban",2])

plot(forest.pts, bg=transparnt.green, col=NA, pch=23, xaxt="n", yaxt="n", xlab=NA, ylab=NA, ylim=c(-0.1, 0.1), xlim=c(-0.1, 0.1))
points(urban.pts, bg=grey.transparant, col=NA, pch=23)
mtext("bgPC 1", side=1, line=1, cex=1)
mtext("bgPC 2", side=2, line=0.2, cex=1)
mtext("Arecibo", side=3, line=0.5, font=2, cex=1)

hpts<-chull(forest.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(forest.pts[hpts,], col=transparnt.green) #plot the lines

hpts<-chull(urban.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(urban.pts[hpts,], col=grey.transparant) #plot the lines

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Arecibo" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=23)
points(mean.urban, bg="darkgrey", pch=23)




#Mayaguez
forest.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="forest",1], gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="forest",2])
urban.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="urban",1], gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="urban",2])

plot(forest.pts, bg=transparnt.green, col=NA, pch=21, xaxt="n", yaxt="n", xlab=NA, ylab=NA, ylim=c(-0.1, 0.1), xlim=c(-0.1, 0.1))
points(urban.pts, bg=grey.transparant, col=NA, pch=21)
mtext("bgPC 1", side=1, line=1, cex=1)
mtext("bgPC 2", side=2, line=0.2, cex=1)
mtext("Mayaguez", side=3, line=0.5, font=2, cex=1)

hpts<-chull(forest.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(forest.pts[hpts,], col=transparnt.green) #plot the lines

hpts<-chull(urban.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(urban.pts[hpts,], col=grey.transparant) #plot the lines

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Mayaguez" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=21)
points(mean.urban, bg="darkgrey", pch=21)



#Ponce
forest.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="forest",1], gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="forest",2])
urban.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="urban",1], gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="urban",2])

plot(forest.pts, bg=transparnt.green, col=NA, pch=22, xaxt="n", yaxt="n", xlab=NA, ylab=NA, ylim=c(-0.1, 0.1), xlim=c(-0.1, 0.1))
points(urban.pts, bg=grey.transparant, col=NA, pch=22)
mtext("bgPC 1", side=1, line=1, cex=1)
mtext("bgPC 2", side=2, line=0.2, cex=1)
mtext("Ponce", side=3, line=0.5, font=2, cex=1)

hpts<-chull(forest.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(forest.pts[hpts,], col=transparnt.green) #plot the lines

hpts<-chull(urban.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(urban.pts[hpts,], col=grey.transparant) #plot the lines

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="Ponce" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=22)
points(mean.urban, bg="darkgrey", pch=22)


#San Juan
forest.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="forest",1], gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="forest",2])
urban.pts<-cbind(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="urban",1], gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="urban",2])

plot(forest.pts, bg=transparnt.green, col=NA, pch=25, xaxt="n", yaxt="n", xlab=NA, ylab=NA, ylim=c(-0.1, 0.1), xlim=c(-0.1, 0.1))
points(urban.pts, bg=grey.transparant, col=NA, pch=25)
mtext("bgPC 1", side=1, line=1, cex=1)
mtext("bgPC 2", side=2, line=0.2, cex=1)
mtext("San Juan", side=3, line=0.5, font=2, cex=1)

hpts<-chull(forest.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(forest.pts[hpts,], col=transparnt.green) #plot the lines

hpts<-chull(urban.pts) #get list of outer points
hpts<-c(hpts, hpts[1]) #duplicate first point to close the polygon
lines(urban.pts[hpts,], col=grey.transparant) #plot the lines

mean.forest<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="forest",1]), mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="forest",2]))
mean.urban<-cbind(mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="urban",1]), mean(gPCA_out$Scores[dat.field$Municipality=="San Juan" & dat.field$Habitat_Category=="urban",2]))
segments(mean.forest[1,1], mean.forest[1,2], mean.urban[1,1], mean.urban[1,2], lwd=2)
points(mean.forest, bg=darkgreen.cust, pch=25)
points(mean.urban, bg="darkgrey", pch=25)


dev.off()


#remove variables we won't need anymore
rm(bgPC1.shape.2sd)
rm(bgPC1.shape.2sd.neg)
rm(bgPC2.shape.2sd)
rm(bgPC2.shape.2sd.neg)
rm(gPCA_out)
rm(gPCA_out.r)
rm(proj.shape.2sd)
rm(proj.shape.2sd.neg)
rm(forest.pts)
rm(urban.pts)
rm(mean.forest)
rm(mean.urban)
rm(eco_random)
rm(hpts)


